% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modified_accelerated_descent.R
\name{accel_nuclear_gradient}
\alias{accel_nuclear_gradient}
\title{Accelerated gradient function for ARD}
\usage{
accel_nuclear_gradient(
  inputs,
  outputs,
  lambda,
  Lipschitz = "regression",
  iterations = 5000,
  etol = 1e-04,
  gamma = 2,
  symmetrize = TRUE
)
}
\arguments{
\item{inputs}{A matrix object. This contains ARD census data in matrix form.
It should be of dimension K x N, where N = village size and K = number of ARD characteristics.}

\item{outputs}{A matrix object. This contains the ARD survey data
in matrix form with size K x M, where N > M = number of households receiving ARD questionairre.}

\item{lambda}{A scalar (numeric) value. This is an initial guess that will be iterated on. It can
alternatively be defined as 'NW', which will set \eqn{\lambda = 2(\sqrt{N} + \sqrt{M})(\sqrt{N} + \sqrt{K})}.}

\item{Lipschitz}{A string. This determines how the Lipschitz constant is computed. 'JiYe' implements
the iterative algorithm outlined in Ji and Ye (2009). 'regression' sets it to the analytically derived
constant for the multivariate regression problem posed in Alidaee et al. (2020). Set to 'regression' by
default.}

\item{iterations}{A scalar (integer) value. It is the number of iterations the user
specifies should occur. Set by default to 5000.}

\item{etol}{A scaler. It is the error tolerance for the algorithm. The algorithm will terminate
when either the maximum number of iterations has been met or the mean absolute error between iterations
is below etol.}

\item{symmetrize}{A boolean value. This captures whether to implement the aforementioned modified
gradient descent algorithm..}
}
\value{
An N x M matrix estimate of network connections.
}
\description{
\code{accel_nuclear_gradient} implements the Accelerated Gradient Algorithm (Algorithm 2)
from Ji & Ye (2009). This should be one of only two functions users interact with directly
from the \emph{ardlasso} package. (The other is \code{\link{matrix_regression}}, which is a wrapper
function for accel_nuclear_gradient, forcing the option Lipschitz == 'regression'.)
When symmetrize is set to \code{TRUE}, this function instead implements Algorithm 1 in
Alidaee, Auerbach, and Leung (2020). Note that Alidaee et al. (2019) have a slight change
in notation, wherein the tuple (N, M) below is equivalent to their (N_2, N_1).
}
